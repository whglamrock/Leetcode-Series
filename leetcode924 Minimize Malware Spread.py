
# O(N^2) BFS solution. Can also use union find
# stupid leetcode allows same solution in java but doesn't allow python to pass

class Solution(object):
    def minMalwareSpread(self, graph, initial):
        """
        :type graph: List[List[int]]
        :type initial: List[int]
        :rtype: int
        """
        groupsOfConnected = []
        for root in initial:
            # means this node has been visited
            if graph[root][root] == 0:
                continue
            connected = self.bfs(graph, root)
            groupsOfConnected.append(connected)
            # print graph, connected

        ans = len(graph) - 1
        maxLen = 0
        for i in initial:
            for connected in groupsOfConnected:
                if len(connected) < maxLen or i not in connected:
                    continue
                if len(connected) > maxLen:
                    ans = i
                    maxLen = len(connected)
                else:
                    ans = min(ans, i)

        return ans

    # return connected nodes
    def bfs(self, graph, root):
        stack = [root]
        connected = {root}
        graph[root][root] = 0
        while stack:
            i = stack.pop()
            for j in xrange(len(graph[i])):
                if j == i:
                    graph[i][i] = 0
                    continue
                if graph[i][j] == 1:
                    stack.append(j)
                    graph[i][j] = 0
                    graph[j][i] = 0
                    connected.add(j)
        return connected



print Solution().minMalwareSpread(graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2])



'''
// java code:

import java.lang.*;
import java.util.*;

class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        List<Set<Integer>> groupsOfConnected = new ArrayList<>();
        for (int root : initial) {
            if (graph[root][root] == 0) {
                continue;
            }
            Set<Integer> connected = bfs(graph, root);
            groupsOfConnected.add(connected);
        }

        int ans = graph.length - 1;
        int maxLen = 0;
        for (int i: initial) {
            for (Set<Integer> connected: groupsOfConnected) {
                if (connected.size() < maxLen || !connected.contains(i)) {
                    continue;
                }
                if (connected.size() > maxLen) {
                    ans = i;
                    maxLen = connected.size();
                } else {
                    ans = Math.min(ans, i);
                }
            }
        }
        
        return ans;
    }

    private Set<Integer> bfs(int[][] graph, int root) {
        final Stack<Integer> stack = new Stack<>();
        final Set<Integer> connected = new HashSet<>();
        stack.add(root);
        connected.add(root);
        graph[root][root] = 0;
        while (!stack.isEmpty()) {
            int i = stack.pop();
            for (int j = 0; j < graph[i].length; j++) {
                if (j == i) {
                    graph[i][j] = 0;
                    continue;
                }
                if (graph[i][j] == 1) {
                    stack.add(j);
                    graph[i][j] = 0;
                    graph[j][i] = 0;
                    connected.add(j);
                }
            }
        }
        return connected;
    }
}
'''
