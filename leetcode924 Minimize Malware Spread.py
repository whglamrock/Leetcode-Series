
# O(N^N) BFS solution. Can also use union find
# stupid leetcode allows same solution in java but doesn't allow python to pass

class Solution(object):
    def minMalwareSpread(self, graph, initial):
        """
        :type graph: List[List[int]]
        :type initial: List[int]
        :rtype: int
        """
        groupsOfConnected = []
        for root in initial:
            # means this node has been visited
            if graph[root][root] == 0:
                continue
            connected = self.bfs(graph, root)
            groupsOfConnected.append(connected)
            # print graph, connected

        ans = len(graph) - 1
        maxLen = 0
        for i in initial:
            for connected in groupsOfConnected:
                if len(connected) < maxLen or i not in connected:
                    continue
                if len(connected) > maxLen:
                    ans = i
                    maxLen = len(connected)
                else:
                    ans = min(ans, i)

        return ans

    # return connected nodes
    def bfs(self, graph, root):
        stack = [root]
        connected = {root}
        graph[root][root] = 0
        while stack:
            i = stack.pop()
            for j in xrange(len(graph[i])):
                if j == i:
                    graph[i][i] = 1
                    continue
                if graph[i][j] == 1:
                    stack.append(j)
                    graph[i][j] = 0
                    graph[j][i] = 0
                    connected.add(j)
        return connected



print Solution().minMalwareSpread(graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2])
